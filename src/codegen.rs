use crate::ir::{IRProgram, IRTask};
use chrono::{DateTime, Local, Timelike, Datelike};
use icalendar::{Calendar, Component, Event, EventLike};
use std::fmt::Write;
use anyhow::{Result, anyhow};
use colored::Colorize;

pub enum OutputFormat {
    Shell,
    Markdown,
    Json,
    Calendar,
}

impl OutputFormat {
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "shell" | "sh" => Some(OutputFormat::Shell),
            "markdown" | "md" => Some(OutputFormat::Markdown),
            "json" => Some(OutputFormat::Json),
            "calendar" | "ics" => Some(OutputFormat::Calendar),
            _ => None,
        }
    }
    
    pub fn extension(&self) -> &'static str {
        match self {
            OutputFormat::Shell => "sh",
            OutputFormat::Markdown => "md",
            OutputFormat::Json => "json",
            OutputFormat::Calendar => "ics",
        }
    }
}

pub fn generate_output(program: &IRProgram, format: OutputFormat) -> Result<String> {
    match format {
        OutputFormat::Shell => emit_shell_script(program),
        OutputFormat::Markdown => emit_markdown(program),
        OutputFormat::Json => emit_json(program),
        OutputFormat::Calendar => emit_calendar(program),
    }
}

fn emit_shell_script(program: &IRProgram) -> Result<String> {
    let mut output = String::new();
    
    // Shell script header
    writeln!(&mut output, "#!/bin/bash")?;
    writeln!(&mut output, "# Generated by Zero Inbox")?;
    writeln!(&mut output, "# Date: {}", Local::now().format("%Y-%m-%d %H:%M:%S"))?;
    writeln!(&mut output, "")?;
    
    // Function to check if notify-send is available
    writeln!(&mut output, "# Check if notification tools are available")?;
    writeln!(&mut output, "HAS_NOTIFY=false")?;
    writeln!(&mut output, "if command -v notify-send &> /dev/null; then")?;
    writeln!(&mut output, "    HAS_NOTIFY=true")?;
    writeln!(&mut output, "elif command -v osascript &> /dev/null; then")?;
    writeln!(&mut output, "    HAS_NOTIFY=true")?;
    writeln!(&mut output, "fi")?;
    writeln!(&mut output, "")?;
    
    // Function to send notifications
    writeln!(&mut output, "function notify() {{")?;
    writeln!(&mut output, "    if [ \"$HAS_NOTIFY\" = true ]; then")?;
    writeln!(&mut output, "        if command -v notify-send &> /dev/null; then")?;
    writeln!(&mut output, "            notify-send \"$1\" \"$2\"")?;
    writeln!(&mut output, "        elif command -v osascript &> /dev/null; then")?;
    writeln!(&mut output, "            osascript -e \"display notification \\\"$2\\\" with title \\\"$1\\\"\"")?;
    writeln!(&mut output, "        fi")?;
    writeln!(&mut output, "    else")?;
    writeln!(&mut output, "        echo \"$1: $2\"")?;
    writeln!(&mut output, "    fi")?;
    writeln!(&mut output, "}}")?;
    writeln!(&mut output, "")?;
    
    // Generate tasks
    for block in &program.blocks {
        writeln!(&mut output, "echo \"[{}]\"", block.name)?;
        
        for task in &block.tasks {
            let task_name = task.display_name();
            let duration = task.duration_minutes();
            
            // Format the start time if available
            let start_time = if let Some(start) = task.scheduled_start {
                start.format("%H:%M").to_string()
            } else {
                "??:??".to_string()
            };
            
            writeln!(&mut output, "# Task: {} ({})", task_name, format_duration(duration))?;
            writeln!(&mut output, "echo \"[{}] Starting: {}\"", start_time, task_name)?;
            writeln!(&mut output, "notify \"Task Start\" \"{}\"", task_name)?;
            
            // If the task has a duration, add a sleep command
            if duration > 0 {
                writeln!(&mut output, "# Sleep for {} seconds", duration * 60)?;
                writeln!(&mut output, "echo \"Waiting for {} minutes...\"", duration)?;
                writeln!(&mut output, "sleep {}", duration * 60)?;
            }
            
            writeln!(&mut output, "echo \"Completed: {}\"", task_name)?;
            writeln!(&mut output, "notify \"Task Complete\" \"{}\"", task_name)?;
            writeln!(&mut output, "")?;
        }
    }
    
    writeln!(&mut output, "echo \"All tasks completed!\"")?;
    writeln!(&mut output, "notify \"Zero Inbox\" \"All tasks completed!\"")?;
    
    Ok(output)
}

fn emit_markdown(program: &IRProgram) -> Result<String> {
    let mut output = String::new();
    
    // Markdown header
    writeln!(&mut output, "# Zero Inbox Plan")?;
    writeln!(&mut output, "")?;
    writeln!(&mut output, "Generated on: {}", Local::now().format("%Y-%m-%d %H:%M:%S"))?;
    writeln!(&mut output, "")?;
    
    // Summary
    writeln!(&mut output, "## Summary")?;
    writeln!(&mut output, "")?;
    writeln!(&mut output, "- Total blocks: {}", program.blocks.len())?;
    writeln!(&mut output, "- Total tasks: {}", program.all_tasks().len())?;
    writeln!(&mut output, "- Total duration: {}", format_duration(program.total_duration()))?;
    writeln!(&mut output, "")?;
    
    // Generate tasks by block
    for block in &program.blocks {
        // Add a fun icon for common block names
        let block_icon = match block.name.to_lowercase().as_str() {
            "morning" => "â˜€ï¸ ",
            "afternoon" => "ðŸŒ¤ï¸ ",
            "evening" => "ðŸŒ™ ",
            "night" => "ðŸŒ‘ ",
            "work" => "ðŸ’¼ ",
            "break" => "â˜• ",
            _ => "",
        };
        // Subtle blue color for block headers (ANSI, will be ignored in plain Markdown)
        let block_header = format!("## {}{}", block_icon, block.name);
        writeln!(&mut output, "{}", block_header)?;
        writeln!(&mut output, "")?;
        
        for task in &block.tasks {
            let task_name = task.display_name();
            let duration = task.duration_minutes();
            
            // Format the start time if available
            let time_info = if let Some(start) = task.scheduled_start {
                format!("{}", start.format("%H:%M"))
            } else {
                "".to_string()
            };
            
            let duration_str = if duration > 0 {
                format!("({})", format_duration(duration))
            } else {
                "".to_string()
            };
            
            let priority_marker = match task.priority {
                crate::ast::Priority::Low => "",
                crate::ast::Priority::Medium => "",
                crate::ast::Priority::High => "\x1b[33mâ­\x1b[0m ", // yellow
                crate::ast::Priority::Critical => "\x1b[31mðŸ”¥\x1b[0m ", // red
            };
            
            // Fun tag icons for common tags, with color
            let tag_icons = |tag: &str| match tag.to_lowercase().as_str() {
                "deepwork" => "ðŸ§ ",
                "admin" => "ðŸ—‚ï¸",
                "health" => "ðŸƒ",
                "learning" => "ðŸ“š",
                "collaboration" => "ðŸ¤",
                "meeting" => "ðŸ“…",
                "focus" => "ðŸŽ¯",
                "break" => "â˜•",
                _ => "",
            };
            let tags = if !task.tags.is_empty() {
                let tag_list: Vec<_> = task.tags.iter()
                    .map(|t| {
                        let icon = tag_icons(t);
                        let colored_tag = format!("\x1b[36m`#{}`\x1b[0m", t); // cyan
                        if icon.is_empty() {
                            colored_tag
                        } else {
                            format!("{} {}", icon, colored_tag)
                        }
                    })
                    .collect();
                format!(" {}", tag_list.join(" "))
            } else {
                "".to_string()
            };
            
            // Format dependencies
            let deps = if !task.depends_on.is_empty() {
                format!(" (depends on: {})", task.depends_on.join(", "))
            } else {
                "".to_string()
            };
            
            let time_prefix = if !time_info.is_empty() { format!("[{}] ", time_info) } else { String::new() };
            // Subtle green checkmark for completed tasks
            let completed = if task.completed { " âœ…" } else { "" };
            writeln!(
                &mut output, 
                "- {} {}**{}** {} {}{}{}",
                time_prefix,
                priority_marker,
                task_name,
                duration_str,
                tags,
                deps,
                completed
            )?;
        }
        
        writeln!(&mut output, "")?;
    }
    
    Ok(output)
}

fn emit_json(program: &IRProgram) -> Result<String> {
    serde_json::to_string_pretty(program).map_err(|e| anyhow!("JSON serialization error: {}", e))
}

fn emit_calendar(program: &IRProgram) -> Result<String> {
    let mut calendar = Calendar::new();
    
    for block in &program.blocks {
        for task in &block.tasks {
            // Skip tasks without scheduled times
            if task.scheduled_start.is_none() || task.scheduled_end.is_none() {
                continue;
            }
            
            let start = task.scheduled_start.unwrap().with_timezone(&chrono::Utc);
            let end = task.scheduled_end.unwrap().with_timezone(&chrono::Utc);
            
            let mut event = Event::new();
            event.summary(&task.display_name());
            event.description(&format!("Block: {}", block.name));
            event.starts(start);
            event.ends(end);
            // Note: icalendar::Event does not support add_category in this version, so we skip adding categories.
            calendar.push(event);
        }
    }
    
    Ok(calendar.to_string())
}

pub fn visualize_schedule(program: &IRProgram) -> Result<String> {
    let mut output = String::new();
    
    // Header
    writeln!(&mut output, "Schedule Visualization")?;
    writeln!(&mut output, "=====================")?;
    writeln!(&mut output, "")?;
    
    // Get the earliest and latest times
    let mut earliest = Local::now();
    let mut latest = Local::now();
    
    let scheduled_tasks: Vec<_> = program.all_tasks()
        .into_iter()
        .filter(|t| t.scheduled_start.is_some() && t.scheduled_end.is_some())
        .collect();
    
    if scheduled_tasks.is_empty() {
        return Ok("No scheduled tasks found.".to_string());
    }
    
    for task in &scheduled_tasks {
        if let Some(start) = task.scheduled_start {
            if start < earliest {
                earliest = start;
            }
        }
        
        if let Some(end) = task.scheduled_end {
            if end > latest {
                latest = end;
            }
        }
    }
    
    // Round to the nearest hour
    earliest = earliest.with_minute(0).unwrap().with_second(0).unwrap();
    latest = if latest.minute() > 0 {
        latest.with_minute(0).unwrap().with_second(0).unwrap() + chrono::Duration::hours(1)
    } else {
        latest.with_minute(0).unwrap().with_second(0).unwrap()
    };
    
    // Create a timeline
    let hours = (latest - earliest).num_hours() + 1;
    
    writeln!(&mut output, "Time | Tasks")?;
    writeln!(&mut output, "-----|------")?;
    
    for hour in 0..hours {
        let current_time = earliest + chrono::Duration::hours(hour);
        let time_str = current_time.format("%H:%M").to_string();
        
        let mut line = format!("{} | ", time_str);
        
        // Find tasks that are active at this time
        for task in &scheduled_tasks {
            if let (Some(start), Some(end)) = (task.scheduled_start, task.scheduled_end) {
                if start <= current_time && end > current_time {
                    // Task is active at this time
                    let task_name = task.display_name();
                    let block_name = &task.block;
                    
                    write!(&mut line, "[{}:{}] ", block_name, task_name)?;
                }
            }
        }
        
        writeln!(&mut output, "{}", line)?;
    }
    
    Ok(output)
}

fn format_duration(minutes: u64) -> String {
    if minutes < 60 {
        format!("{}m", minutes)
    } else if minutes % 60 == 0 {
        format!("{}h", minutes / 60)
    } else {
        format!("{}h {}m", minutes / 60, minutes % 60)
    }
}