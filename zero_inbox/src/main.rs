use clap::Parser;
use std::fs;
use std::path::PathBuf;

use zero_inbox::{compile, parser, ir};
use zero_inbox::error::Result;

#[derive(Parser, Debug)]
#[command(name = "zibox")]
#[command(about = "Zero Inbox Compiler - Transform task definitions into optimized execution plans")]
#[command(version = "0.1.0")]
struct Args {
    /// Input .zbx file to compile
    input: PathBuf,

    /// Output format (markdown, shell, json)
    #[arg(short, long, default_value = "markdown")]
    output_format: String,

    /// Output file (default: stdout)
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Show verbose output
    #[arg(short, long, action = clap::ArgAction::Count)]
    verbose: u8,

    /// Optimization level (0-2)
    #[arg(short = 'O', long, default_value = "1")]
    opt_level: u8,

    /// Show the IR instead of compiling
    #[arg(long)]
    show_ir: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();
    
    // Setup logging based on verbosity level
    let log_level = match args.verbose {
        0 => tracing::Level::WARN,
        1 => tracing::Level::INFO,
        2 => tracing::Level::DEBUG,
        _ => tracing::Level::TRACE,
    };
    
    tracing_subscriber::fmt()
        .with_max_level(log_level)
        .init();
    
    tracing::info!("Compiling: {:?}", args.input);
    
    // Read input file
    let input = fs::read_to_string(&args.input)
        .map_err(|_| zero_inbox::error::Error::FileNotFound(args.input.clone()))?;
    
    // Parse the input
    let program = parser::parse(&input)?;
    
    // Lower to IR
    let mut ir_program = ir::lower(program)?;
    
    // Optimize
    if args.opt_level > 0 {
        ir::optimize(&mut ir_program);
    }
    
    // Show IR if requested
    if args.show_ir {
        println!("{:#?}", ir_program);
        return Ok(());
    }
    
    // Generate output
    let output = match args.output_format.as_str() {
        "markdown" => generate_markdown(&ir_program),
        "shell" => generate_shell_script(&ir_program),
        "json" => generate_json(&ir_program)?,
        _ => return Err(format!("Unsupported output format: {}", args.output_format).into()),
    };
    
    // Write to file or stdout
    if let Some(output_path) = args.output {
        fs::write(output_path, output)?;
    } else {
        println!("{}", output);
    }
    
    Ok(())
}

fn generate_markdown(program: &ir::IRProgram) -> String {
    let mut output = String::new();
    
    output.push_str("# Zero Inbox Schedule\n\n");
    
    for block in &program.blocks {
        output.push_str(&format!("## {}\n\n", block.name));
        
        if let (Some(start), Some(end)) = (&block.start_time, &block.end_time) {
            output.push_str(&format!("**Time:** {} - {}\n\n", 
                start.format("%H:%M"), 
                end.format("%H:%M")
            ));
        }
        
        output.push_str("| Task | Duration |\n");
        output.push_str("|------|----------|\n");
        
        for task in &block.tasks {
            let duration = task.duration
                .map(|d| format!("{}m", d.as_secs() / 60))
                .unwrap_or_else(|| "-".to_string());
                
            output.push_str(&format!("| {} | {} |\n", task.name, duration));
        }
        
        output.push_str("\n");
    }
    
    output
}

fn generate_shell_script(program: &ir::IRProgram) -> String {
    let mut output = String::new();
    
    output.push_str("#!/bin/bash\n\n");
    output.push_str("# Generated by Zero Inbox Compiler\n");
    output.push_str("# Total estimated duration: ");
    
    let total_minutes = program.total_duration.as_secs() / 60;
    if total_minutes >= 60 {
        output.push_str(&format!("{}h{}m\n\n", 
            total_minutes / 60, 
            total_minutes % 60
        ));
    } else {
        output.push_str(&format!("{}m\n\n", total_minutes));
    }
    
    for block in &program.blocks {
        output.push_str(&format!("echo '=== {} ==='\n", block.name.to_uppercase()));
        
        for task in &block.tasks {
            if let Some(duration) = task.duration {
                output.push_str(&format!("echo 'Starting: {} ({}m)'\n", 
                    task.name, 
                    duration.as_secs() / 60
                ));
                
                // In a real implementation, this would run the actual task
                output.push_str(&format!("# Run: {}({})\n", 
                    task.name, 
                    task.params.join(", ")
                ));
                
                // Simulate task duration
                output.push_str(&format!("sleep {}\n", duration.as_secs()));
                
                output.push_str(&format!("echo 'Completed: {}'\n\n", task.name));
            } else {
                output.push_str(&format!("echo 'Task: {}'\n", task.name));
                output.push_str(&format!("# Run: {}({})\n\n", 
                    task.name, 
                    task.params.join(", ")
                ));
            }
        }
    }
    
    output.push_str("echo 'All tasks completed!\n'");
    output
}

fn generate_json(program: &ir::IRProgram) -> Result<String> {
    serde_json::to_string_pretty(program)
        .map_err(|e| e.into())
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic() {
        // Basic test to verify the project builds
        assert!(true);
    }
}
